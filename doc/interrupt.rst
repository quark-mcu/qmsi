QMSI Interrupt Architecture
###########################

Overview
********

This write-up summarises the interrupt setup and flow in QMSI.

The interrupt scheme here discussed applies to bare-metal scenarios and to OSes
not using their own interrupt driver (e.g. QMSI on Contiki).

.. contents::

Architecture
************

The QMSI interrupt API is independent of the CPU architecture and currently
supports x86 and ARC cores.

Interrupt vectors and IRQs are allocated at runtime.
An IRQ is steered to the same core that registers it.
The API does not expose configuration for IRQ polarity and triggering type.
These configurations are internally set by the interrupt driver.

ISRs reuse the same application stack.

ISRs are designed to be portable across different interrupt drivers than the
QMSI bare-metal driver presented here. See the `Portability Considerations`_
section for more details.

Requirements
============

The interrupt API has the following set of requirements, which are typically
covered by the boot ROM or a second stage bootloader:

* Vector table initialization
* Interrupt controller initialization

The API
*******

The API header is at ``drivers/include/qm_interrupt.h``.
QMSI drivers also provide default ISRs which are declared at:

* SoC fabric drivers: ``drivers/include/qm_isr.h``
* Sensor Subsystem drivers: ``drivers/include/qm_ss_isr.h``

See headers' Doxygen documentation for more details.

API Functions
=============

The header provides functions to:

* Register an interrupt vector or IRQ
* Mask/unmask an IRQ
* Unconditionally enable/disable interrupt delivery to the core
* Map an IRQ to an interrupt vector.
* Lock / unlock interrupts based on previously saved IF flag state

Sample Flow
===========

This example shows how to register a custom RTC IRQ handler using the QMSI
interrupt API.

::

        static QM_ISR_DECLARE(my_rtc_isr)
        {
                /* Handle interrupt here */

                /* Signal end of interrupt via QM_ISR_EOI macro */
                QM_ISR_EOI(QM_IRQ_RTC_0_INT_VECTOR);
        }

        int main(void)
        {
                /*
                 * Request IRQ for the RTC.
                 * This installs the custom_rtc_isr ISR to the RTC vector and
                 * steers the interrupt to the core which is running this code.
                 */
                qm_irq_request(QM_IRQ_RTC_0_INT, my_rtc_isr);

                return 0;
        }

Portability considerations
**************************

As the sample flow shows, the ISR uses the ``QM_ISR_DECLARE()`` and
``QM_ISR_EOI()`` macros.
These macros are used for portability with RTOSes and allow to reuse ISRs with
other interrupt subsystems.

These macros are controlled by the ``ENABLE_EXTERNAL_ISR_HANDLING`` optional
make switch. There are two possible values for
``ENABLE_EXTERNAL_ISR_HANDLING``:

[TODO suggest renaming to HAS_ISR_DISPATCHER]

* ``ENABLE_EXTERNAL_ISR_HANDLING=0`` (default)
  The ISR is built as a native interrupt handler.
  The QMSI interrupt driver connects the handler directly to its interrupt
  vector. The EOI is generated by the ``QM_ISR_EOI()`` macro.
* ``ENABLE_EXTERNAL_ISR_HANDLING=1``
  The ISR is built as an interrupt sub-routine.
  The non-QMSI interrupt driver connects the ISR to its interrupt dispatcher.
  As a consequence ``QM_ISR_EOI()`` expands to nothing.

Unsupported Features
********************

The bare-metal interrupt API does not support:

* Central ISR dispatcher
* Shared IRQs
* Nested interrupts

Also there is no specific support for exceptions.
It is possible to handle an exception by registering it as a standard
interrupt, with the caveat exception-specific details must be explicitly
handled in the ISR (e.g. error codes pushed in the stack by x86 hardware).
